<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>前后端通信测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        .container {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        pre {
            background-color: #1e1e1e;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
            max-height: 400px;
            overflow-y: auto;
        }
        .success { color: #28a745; }
        .error { color: #dc3545; }
        .info { color: #17a2b8; }
        .warning { color: #ffc107; }
    </style>
</head>
<body>
    <h1>前后端通信测试</h1>
    
    <div class="container">
        <h2>1. 基础连接测试</h2>
        <button onclick="testBasicConnection()">测试基础连接</button>
        <div id="basic-result"></div>
    </div>
    
    <div class="container">
        <h2>2. 加密通信测试</h2>
        <button onclick="testEncryptedCommunication()">测试加密通信</button>
        <div id="encrypted-result"></div>
    </div>
    
    <div class="container">
        <h2>3. 搜索功能测试</h2>
        <button onclick="testSearchFunction()">测试搜索功能</button>
        <div id="search-result"></div>
    </div>

    <script>
        // 简化的对称加密工具
        class SimpleEncryption {
            static SECRET_KEY = "mtg-ai-secret-key-2024";

            static xorEncrypt(data, key) {
                let encrypted = "";
                const keyLength = key.length;
                for (let i = 0; i < data.length; i++) {
                    const keyChar = key[i % keyLength];
                    encrypted += String.fromCharCode(
                        data.charCodeAt(i) ^ keyChar.charCodeAt(0)
                    );
                }
                return encrypted;
            }

            static xorDecrypt(encryptedData, key) {
                return this.xorEncrypt(encryptedData, key);
            }

            static encrypt(data) {
                try {
                    const jsonStr = JSON.stringify(data, null, 0);
                    const encrypted = this.xorEncrypt(jsonStr, this.SECRET_KEY);
                    const bytes = new Uint8Array(encrypted.length);
                    for (let i = 0; i < encrypted.length; i++) {
                        bytes[i] = encrypted.charCodeAt(i) & 0xFF;
                    }
                    const latin1String = String.fromCharCode.apply(null, Array.from(bytes));
                    return btoa(latin1String);
                } catch (error) {
                    console.error("加密失败:", error);
                    throw error;
                }
            }

            static decrypt(encryptedData) {
                try {
                    const decoded = atob(encryptedData);
                    const originalString = decoded;
                    const decrypted = this.xorDecrypt(originalString, this.SECRET_KEY);
                    return JSON.parse(decrypted);
                } catch (error) {
                    console.error("解密失败:", error);
                    throw error;
                }
            }

            static isEncrypted(data) {
                return data && typeof data === "object" && "encrypted_data" in data;
            }

            static createEncryptedPayload(data) {
                const encryptedData = this.encrypt(data);
                return {
                    encrypted_data: encryptedData,
                    timestamp: Date.now(),
                    version: "1.0",
                };
            }
        }

        function log(message, type = 'info', targetId = 'basic-result') {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            console.log(logMessage);
            
            const resultDiv = document.getElementById(targetId);
            const pre = document.createElement('pre');
            pre.className = type;
            pre.textContent = logMessage;
            resultDiv.appendChild(pre);
        }

        async function testBasicConnection() {
            log("=== 开始基础连接测试 ===", 'info', 'basic-result');
            
            try {
                const response = await fetch('https://mtg-ai-backend.onrender.com/api/test', {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    }
                });
                
                log(`响应状态: ${response.status}`, 'info', 'basic-result');
                const result = await response.json();
                log(`响应数据: ${JSON.stringify(result, null, 2)}`, 'success', 'basic-result');
                
                if (response.ok) {
                    log("✅ 基础连接测试成功！", 'success', 'basic-result');
                } else {
                    log("❌ 基础连接测试失败！", 'error', 'basic-result');
                }
                
            } catch (error) {
                log(`❌ 基础连接测试失败: ${error}`, 'error', 'basic-result');
            }
        }

        async function testEncryptedCommunication() {
            log("=== 开始加密通信测试 ===", 'info', 'encrypted-result');
            
            const testData = {
                query: "蓝色瞬间法术",
                language: "zh",
                api_key: "test_key_123"
            };
            
            try {
                log(`原始数据: ${JSON.stringify(testData, null, 2)}`, 'info', 'encrypted-result');
                
                // 创建加密载荷
                const encryptedPayload = SimpleEncryption.createEncryptedPayload(testData);
                log(`加密载荷: ${JSON.stringify(encryptedPayload, null, 2)}`, 'info', 'encrypted-result');
                
                // 发送到后端
                log("发送到后端...", 'info', 'encrypted-result');
                const response = await fetch('https://mtg-ai-backend.onrender.com/api/debug-encryption', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(encryptedPayload)
                });
                
                log(`响应状态: ${response.status}`, 'info', 'encrypted-result');
                const result = await response.json();
                log(`后端响应: ${JSON.stringify(result, null, 2)}`, 'info', 'encrypted-result');
                
                if (response.ok) {
                    log("✅ 加密通信测试成功！", 'success', 'encrypted-result');
                } else {
                    log("❌ 加密通信测试失败！", 'error', 'encrypted-result');
                }
                
            } catch (error) {
                log(`❌ 加密通信测试失败: ${error}`, 'error', 'encrypted-result');
            }
        }

        async function testSearchFunction() {
            log("=== 开始搜索功能测试 ===", 'info', 'search-result');
            
            const searchData = {
                query: "蓝色瞬间法术",
                language: "zh",
                sort: "name",
                order: "asc"
            };
            
            try {
                log(`搜索数据: ${JSON.stringify(searchData, null, 2)}`, 'info', 'search-result');
                
                // 创建加密载荷
                const encryptedPayload = SimpleEncryption.createEncryptedPayload(searchData);
                log(`加密载荷: ${JSON.stringify(encryptedPayload, null, 2)}`, 'info', 'search-result');
                
                // 发送搜索请求
                log("发送搜索请求...", 'info', 'search-result');
                const response = await fetch('https://mtg-ai-backend.onrender.com/api/search', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(encryptedPayload)
                });
                
                log(`响应状态: ${response.status}`, 'info', 'search-result');
                const result = await response.json();
                log(`搜索结果: ${JSON.stringify(result, null, 2)}`, 'info', 'search-result');
                
                if (response.ok) {
                    log("✅ 搜索功能测试成功！", 'success', 'search-result');
                    if (result.cards && result.cards.length > 0) {
                        log(`找到 ${result.cards.length} 张卡牌`, 'success', 'search-result');
                    } else {
                        log("未找到卡牌", 'warning', 'search-result');
                    }
                } else {
                    log("❌ 搜索功能测试失败！", 'error', 'search-result');
                }
                
            } catch (error) {
                log(`❌ 搜索功能测试失败: ${error}`, 'error', 'search-result');
            }
        }
    </script>
</body>
</html>
