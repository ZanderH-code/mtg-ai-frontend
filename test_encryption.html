<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>加密测试</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background-color: #1a1a1a;
            color: #ffffff;
        }
        .container {
            background-color: #2a2a2a;
            padding: 20px;
            border-radius: 8px;
            margin-bottom: 20px;
        }
        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
        }
        button:hover {
            background-color: #0056b3;
        }
        pre {
            background-color: #1e1e1e;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: pre-wrap;
        }
        .success { color: #28a745; }
        .error { color: #dc3545; }
        .info { color: #17a2b8; }
    </style>
</head>
<body>
    <h1>加密测试页面</h1>
    
    <div class="container">
        <h2>前端加密测试</h2>
        <button onclick="testFrontendEncryption()">测试前端加密</button>
        <div id="frontend-result"></div>
    </div>
    
    <div class="container">
        <h2>后端通信测试</h2>
        <button onclick="testBackendCommunication()">测试后端通信</button>
        <div id="backend-result"></div>
    </div>

    <script>
        // 简化的对称加密工具
        class SimpleEncryption {
            static SECRET_KEY = "mtg-ai-secret-key-2024";

            static xorEncrypt(data, key) {
                let encrypted = "";
                const keyLength = key.length;
                for (let i = 0; i < data.length; i++) {
                    const keyChar = key[i % keyLength];
                    encrypted += String.fromCharCode(
                        data.charCodeAt(i) ^ keyChar.charCodeAt(0)
                    );
                }
                return encrypted;
            }

            static xorDecrypt(encryptedData, key) {
                return this.xorEncrypt(encryptedData, key);
            }

            static encrypt(data) {
                try {
                    const jsonStr = JSON.stringify(data, null, 0);
                    const encrypted = this.xorEncrypt(jsonStr, this.SECRET_KEY);
                    const bytes = new Uint8Array(encrypted.length);
                    for (let i = 0; i < encrypted.length; i++) {
                        bytes[i] = encrypted.charCodeAt(i) & 0xFF;
                    }
                    const latin1String = String.fromCharCode.apply(null, Array.from(bytes));
                    return btoa(latin1String);
                } catch (error) {
                    console.error("加密失败:", error);
                    throw error;
                }
            }

            static decrypt(encryptedData) {
                try {
                    const decoded = atob(encryptedData);
                    const originalString = decoded;
                    const decrypted = this.xorDecrypt(originalString, this.SECRET_KEY);
                    return JSON.parse(decrypted);
                } catch (error) {
                    console.error("解密失败:", error);
                    throw error;
                }
            }

            static isEncrypted(data) {
                return data && typeof data === "object" && "encrypted_data" in data;
            }

            static createEncryptedPayload(data) {
                const encryptedData = this.encrypt(data);
                return {
                    encrypted_data: encryptedData,
                    timestamp: Date.now(),
                    version: "1.0",
                };
            }
        }

        function log(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            console.log(logMessage);
            
            const resultDiv = document.getElementById('frontend-result');
            const pre = document.createElement('pre');
            pre.className = type;
            pre.textContent = logMessage;
            resultDiv.appendChild(pre);
        }

        function logBackend(message, type = 'info') {
            const timestamp = new Date().toLocaleTimeString();
            const logMessage = `[${timestamp}] ${message}`;
            console.log(logMessage);
            
            const resultDiv = document.getElementById('backend-result');
            const pre = document.createElement('pre');
            pre.className = type;
            pre.textContent = logMessage;
            resultDiv.appendChild(pre);
        }

        async function testFrontendEncryption() {
            log("=== 开始前端加密测试 ===", 'info');
            
            const testData = {
                query: "蓝色瞬间法术",
                language: "zh",
                api_key: "test_key_123"
            };
            
            try {
                log(`原始数据: ${JSON.stringify(testData, null, 2)}`, 'info');
                
                // 加密
                log("开始加密...", 'info');
                const encryptedData = SimpleEncryption.encrypt(testData);
                log(`加密结果: ${encryptedData}`, 'info');
                log(`加密数据长度: ${encryptedData.length}`, 'info');
                
                // 检查是否已加密
                const isEncrypted = SimpleEncryption.isEncrypted({ encrypted_data: encryptedData });
                log(`是否已加密: ${isEncrypted}`, 'info');
                
                // 解密
                log("开始解密...", 'info');
                const decryptedData = SimpleEncryption.decrypt(encryptedData);
                log(`解密结果: ${JSON.stringify(decryptedData, null, 2)}`, 'info');
                
                // 验证结果
                if (JSON.stringify(decryptedData) === JSON.stringify(testData)) {
                    log("✅ 加密解密测试成功！", 'success');
                } else {
                    log("❌ 加密解密测试失败！", 'error');
                    log(`期望: ${JSON.stringify(testData)}`, 'error');
                    log(`实际: ${JSON.stringify(decryptedData)}`, 'error');
                }
                
            } catch (error) {
                log(`❌ 加密测试失败: ${error}`, 'error');
            }
        }

        async function testBackendCommunication() {
            logBackend("=== 开始后端通信测试 ===", 'info');
            
            const testData = {
                query: "蓝色瞬间法术",
                language: "zh",
                api_key: "test_key_123"
            };
            
            try {
                logBackend(`原始数据: ${JSON.stringify(testData, null, 2)}`, 'info');
                
                // 创建加密载荷
                const encryptedPayload = SimpleEncryption.createEncryptedPayload(testData);
                logBackend(`加密载荷: ${JSON.stringify(encryptedPayload, null, 2)}`, 'info');
                
                // 发送到后端
                logBackend("发送到后端...", 'info');
                const response = await fetch('https://mtg-ai-backend.onrender.com/api/debug-encryption', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify(encryptedPayload)
                });
                
                logBackend(`响应状态: ${response.status}`, 'info');
                const result = await response.json();
                logBackend(`后端响应: ${JSON.stringify(result, null, 2)}`, 'info');
                
                if (response.ok) {
                    logBackend("✅ 后端通信测试成功！", 'success');
                } else {
                    logBackend("❌ 后端通信测试失败！", 'error');
                }
                
            } catch (error) {
                logBackend(`❌ 后端通信测试失败: ${error}`, 'error');
            }
        }
    </script>
</body>
</html>
